From eb3ad0700b5ede126328d1cb59ca20253f33c55f Mon Sep 17 00:00:00 2001
From: Khurana <prakhar.khurana@siemens.com>
Date: Tue, 19 Aug 2025 15:25:01 +0530
Subject: [PATCH] backend of the parser

---
 README.md           | 118 +++++++++++++++++++++++++-
 check3.il           | 197 ++++++++++++++++++++++++++++++++++++++++++++
 src/parser/il.rs    |  93 +++++++++++++++++++++
 src/parser/mod.rs   |   2 +
 src/rules/policy.rs |   2 +-
 5 files changed, 409 insertions(+), 3 deletions(-)
 create mode 100644 check3.il
 create mode 100644 src/parser/il.rs

diff --git a/README.md b/README.md
index 1e5ac06..25a3963 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,117 @@
-# aaaaaaa
+PLC Secure Coding Practices Checker
+plc_practices_checker is a command-line static analysis tool written in Rust to automatically check Programmable Logic Controller (PLC) source code against the "Top 20 Secure PLC Coding Practices." It helps developers and automation engineers identify and mitigate common security vulnerabilities in their industrial control system logic before deployment.
 
-###target/debug/plc_secure_checker check2.xml --policy policy.json
+The tool parses PLC source files, builds an Abstract Syntax Tree (AST), and runs a series of rule-based checks to find potential security flaws.
+
+Key Features
+Static Analysis: Checks PLC code without needing to run it on actual hardware.
+
+Multi-Language Support: Parses multiple common PLC programming languages.
+
+Comprehensive Rule Set: Implements a significant portion of the Top 20 Secure PLC Coding Practices.
+
+Policy-Driven Checks: Allows for custom, site-specific rules via an optional policy.json file.
+
+Clear, Actionable Output: Reports violations with the rule number, line number, a clear reason, and a suggestion for remediation.
+
+Command-Line Interface: Easy to integrate into automated workflows and CI/CD pipelines.
+
+Supported PLC Languages
+The checker currently supports the following PLC source file formats:
+
+Siemens SCL (.scl, .st): Structured Control Language, a high-level, Pascal-like language.
+
+PLCOpen XML (.xml): A standard, vendor-neutral format for exporting PLC projects, including logic from graphical languages like FBD and LD.
+
+Instruction List (.il, .awl): A low-level, assembly-like language.
+
+Implemented Security Rules
+This tool checks for the following secure coding practices:
+
+Rule 1: Modularize PLC Code (Checks for excessive complexity)
+
+Rule 2: Track Operating Modes
+
+Rule 4: Use PLC Flags as Integrity Checks (for division)
+
+Rule 5: Use Checksum Integrity Checks
+
+Rule 6: Validate Timers and Counters
+
+Rule 7: Validate Paired Inputs/Outputs (Requires policy.json)
+
+Rule 8: Validate HMI Input Variables
+
+Rule 9: Validate Indirections (Array indexing)
+
+Rule 10: Assign Designated Register Blocks (Requires policy.json)
+
+Rules 11 & 12: Instrument for Plausibility Checks
+
+Rule 15: Define a Safe Process State on Restart
+
+Rule 16: Summarize PLC Cycle Times
+
+Rule 17: Log PLC Uptime
+
+Rule 18: Log PLC Hard Stops
+
+Rule 19: Monitor PLC Memory Usage
+
+Rule 20: Trap False Negatives/Positives for Critical Alerts
+
+Getting Started
+Prerequisites
+You need to have the Rust toolchain (including cargo) installed on your system.
+
+Building the Project
+Clone the repository:
+
+git clone <your-repository-url>
+cd plc_practices_checker
+
+Build the project using Cargo:
+
+cargo build --release
+
+The executable will be located at target/release/plc_practices_checker.
+
+Usage
+Run the checker from the command line, providing the path to the PLC source file you want to analyze.
+
+./target/release/plc_practices_checker /path/to/your/program.scl
+
+Using a Policy File
+For rules that require site-specific configuration (like Rule 7 and Rule 10), you can provide an optional policy file.
+
+./target/release/plc_practices_checker /path/to/your/program.scl --policy /path/to/policy.json
+
+The Policy File
+The policy.json file allows you to customize certain rules. If this file is not provided, the rules that depend on it will be skipped.
+
+Example policy.json
+{
+  "pairs": [
+    ["Motor_Fwd", "Motor_Rev"],
+    ["Valve_Open", "Valve_Close"]
+  ],
+  "memory_areas": [
+    { "address": "%MW100-%MW200", "access": "ReadOnly" },
+    { "address": "%M50-%M80",     "access": "ReadWrite" }
+  ]
+}
+
+pairs: Used by Rule 7. Defines pairs of signals (e.g., forward and reverse motor commands) that should never be active at the same time.
+
+memory_areas: Used by Rule 10. Defines specific memory regions and their intended access level (e.g., ReadOnly). The tool will flag any write operations to a ReadOnly area.
+
+Example Output
+When violations are found, the tool prints a clear report to the console for each failed rule.
+
+##Rule 4: Use PLC flags as integrity checks -- NOT FOLLOWED--Line 192: Division operation without status-word / zero-divisor guard Wrap division inside IF SW.OV=0 AND SW.OS=0 AND divisor<>0 THEN ...
+##Rule 8: Validate HMI input variables -- NOT FOLLOWED--Line 100: HMI/DB variable 'HMI_Cut_Speed' used without prior sanitization Precede usage with range-checking IF or plausibility check.
+##Rule 15: Define a safe restart state -- NOT FOLLOWED--Line 0: OB100 (Startup OB) not found Add OB100 and initialize outputs to safe state.
+
+If a rule is followed, it is marked as OK.
+
+##Rule 1: Modularize PLC Code -- OK
diff --git a/check3.il b/check3.il
new file mode 100644
index 0000000..9157eab
--- /dev/null
+++ b/check3.il
@@ -0,0 +1,197 @@
+
+LD      HMI_Start_Cycle     // Load the start button status
+ANDN    System_Fault        // AND NOT fault active
+JMPC    START_SEQ           // Jump if start is pressed
+LD      Current_State
+EQ      0                   // If state is 0 (Idle)
+ST      Idle_Lamp           // Turn on Idle light
+JMP     END_PROGRAM         // End cycle if not starting
+
+START_SEQ:
+LD      Part_Present
+JMPNC   NO_PART_FAULT       // Jump if no part is present to fault state
+
+// State 0: Idle / Homing Sequence
+LD      Current_State
+EQ      0
+JMPC    STATE_10            // If state is 0, jump to state 10 (start homing)
+
+// State 10: Move to Home Position (X-Axis)
+STATE_10:
+LD      Current_State
+EQ      10
+JMPC    MOVE_HOME_X
+JMP     STATE_20
+
+MOVE_HOME_X:
+LDN     Home_X              // Load NOT Home_X sensor
+ST      Motor_X_Reverse     // Move X towards home
+LD      Home_X
+JMPC    SET_STATE_20        // If at home, go to next state
+JMP     END_PROGRAM
+
+SET_STATE_20:
+LD      20
+ST      Current_State
+
+// State 20: Move to Home Position (Y-Axis)
+STATE_20:
+LD      Current_State
+EQ      20
+JMPC    MOVE_HOME_Y
+JMP     STATE_30
+
+MOVE_HOME_Y:
+LDN     Home_Y              // Load NOT Home_Y sensor
+ST      Motor_Y_Reverse     // Move Y towards home
+LD      Home_Y
+JMPC    SET_STATE_30        // If at home, go to next state
+JMP     END_PROGRAM
+
+SET_STATE_30:
+LD      30
+ST      Current_State
+
+// State 30: Move to Start Corner (Position 0,0)
+STATE_30:
+LD      Current_State
+EQ      30
+JMPC    MOVE_TO_START
+JMP     STATE_40
+
+MOVE_TO_START:
+LD      0
+ST      Target_X_Pos
+ST      Target_Y_Pos
+// (Assume a separate motion block handles moving to Target positions)
+// For this example, we'll just set the state
+LD      40
+ST      Current_State
+
+// State 40: Lower Cutter
+STATE_40:
+LD      Current_State
+EQ      40
+JMPC    LOWER_CUTTER
+JMP     STATE_50
+
+LOWER_CUTTER:
+ST      Cutter_Down_Solenoid // Lower the cutting tool
+LD      50
+ST      Current_State
+
+// State 50: Cut along X-axis to position 4
+STATE_50:
+LD      Current_State
+EQ      50
+JMPC    CUT_X1
+JMP     STATE_60
+
+CUT_X1:
+LD      4                   // Target X position is 4
+ST      Target_X_Pos
+// Here we have a potential issue: using HMI value directly
+LD      HMI_Cut_Speed       // Load speed from HMI
+ST      Motor_X_Speed       // Set motor speed
+LD      Current_X_Pos
+GE      Target_X_Pos        // Check if X position is Greater or Equal to target
+JMPC    SET_STATE_60
+JMP     END_PROGRAM
+
+SET_STATE_60:
+LD      60
+ST      Current_State
+
+// State 60: Cut along Y-axis to position 4
+STATE_60:
+LD      Current_State
+EQ      60
+JMPC    CUT_Y1
+JMP     STATE_70
+
+CUT_Y1:
+LD      4                   // Target Y position is 4
+ST      Target_Y_Pos
+LD      HMI_Cut_Speed
+ST      Motor_Y_Speed
+LD      Current_Y_Pos
+GE      Target_Y_Pos
+JMPC    SET_STATE_70
+JMP     END_PROGRAM
+
+SET_STATE_70:
+LD      70
+ST      Current_State
+
+// State 70: Cut along X-axis back to position 0
+STATE_70:
+LD      Current_State
+EQ      70
+JMPC    CUT_X2
+JMP     STATE_80
+
+CUT_X2:
+LD      0                   // Target X position is 0
+ST      Target_X_Pos
+LD      HMI_Cut_Speed
+ST      Motor_X_Speed
+LD      Current_X_Pos
+LE      Target_X_Pos        // Check if X position is Less or Equal to target
+JMPC    SET_STATE_80
+JMP     END_PROGRAM
+
+SET_STATE_80:
+LD      80
+ST      Current_State
+
+// State 80: Cut along Y-axis back to position 0
+STATE_80:
+LD      Current_State
+EQ      80
+JMPC    CUT_Y2
+JMP     STATE_90
+
+CUT_Y2:
+LD      0                   // Target Y position is 0
+ST      Target_Y_Pos
+LD      HMI_Cut_Speed
+ST      Motor_Y_Speed
+LD      Current_Y_Pos
+LE      Target_Y_Pos
+JMPC    SET_STATE_90
+JMP     END_PROGRAM
+
+SET_STATE_90:
+LD      90
+ST      Current_State
+
+// State 90: Raise Cutter and complete cycle
+STATE_90:
+LD      Current_State
+EQ      90
+JMPC    RAISE_CUTTER
+JMP     END_PROGRAM
+
+RAISE_CUTTER:
+LDN     Cutter_Down_Solenoid // De-energize solenoid to raise cutter
+ST      Cutter_Down_Solenoid
+// Another potential issue: unguarded division
+LD      Total_Parts
+ADD     1
+ST      Total_Parts
+LD      Cycle_Time_Total
+ADD     OB1_PREV_CYCLE
+ST      Cycle_Time_Total
+LD      Cycle_Time_Total
+DIV     Total_Parts         // Calculate average cycle time
+ST      HMI_Avg_Cycle_Time
+LD      0                   // Reset state machine to Idle
+ST      Current_State
+
+// Fault Handling
+NO_PART_FAULT:
+LD      TRUE
+ST      No_Part_Fault_Alarm
+
+END_PROGRAM:
+// End of scan
\ No newline at end of file
diff --git a/src/parser/il.rs b/src/parser/il.rs
new file mode 100644
index 0000000..2ee04b7
--- /dev/null
+++ b/src/parser/il.rs
@@ -0,0 +1,93 @@
+//! Simplified parser for Instruction List (IL / AWL).
+//! Translates accumulator-based logic (LD/ADD/ST) into the unified AST.
+
+use std::fs;
+use std::path::Path;
+use crate::ast::{BinOp, Expression, Function, FunctionKind, Program, Statement, Variable};
+
+pub fn parse_il(path: &Path) -> Result<Program, String> {
+    let src = fs::read_to_string(path).map_err(|e| format!("read error: {e}"))?;
+    parse_il_from_str(&src)
+}
+
+pub fn parse_il_from_str(src: &str) -> Result<Program, String> {
+    let mut program = Program { functions: vec![] };
+
+    // Assume a single function block for simplicity in this example.
+    let mut current_func = Function {
+        name: "IL_Program".to_string(),
+        kind: FunctionKind::FC, // Or detect from source
+        statements: vec![],
+        line: 1,
+    };
+
+    // The "accumulator" or Current Result (CR) of the PLC.
+    let mut current_result: Option<Expression> = None;
+
+    for (i, line_raw) in src.lines().enumerate() {
+        let line = line_raw.trim();
+        let line_no = i + 1;
+
+        if line.is_empty() || line.starts_with("//") {
+            continue;
+        }
+
+        let mut parts = line.split_whitespace();
+        let instruction = parts.next().unwrap_or("").to_uppercase();
+        let operand = parts.next().map(|s| s.to_string());
+
+        match instruction.as_str() {
+            "LD" => { // Load value into the accumulator
+                if let Some(op) = operand {
+                    current_result = Some(parse_operand(&op, line_no));
+                }
+            }
+            "ST" => { // Store accumulator value into a variable
+                if let (Some(target_var), Some(value_expr)) = (operand, current_result.take()) {
+                    let stmt = Statement::Assign {
+                        target: Variable { name: target_var },
+                        value: value_expr,
+                        line: line_no,
+                    };
+                    current_func.statements.push(stmt);
+                }
+            }
+            "ADD" | "SUB" | "MUL" | "DIV" => {
+                if let (Some(right_op), Some(left_expr)) = (operand, current_result.take()) {
+                    let op_kind = match instruction.as_str() {
+                        "ADD" => BinOp::Add,
+                        "SUB" => BinOp::Sub,
+                        "MUL" => BinOp::Mul,
+                        _ => BinOp::Div,
+                    };
+
+                    let new_expr = Expression::BinaryOp {
+                        op: op_kind,
+                        left: Box::new(left_expr),
+                        right: Box::new(parse_operand(&right_op, line_no)),
+                        line: line_no,
+                    };
+                    current_result = Some(new_expr);
+                }
+            }
+            // Other IL instructions like JMP, CAL, etc., could be added here.
+            _ => {}
+        }
+    }
+
+    program.functions.push(current_func);
+    Ok(program)
+}
+
+/// Helper to parse an operand into a literal or a variable reference.
+fn parse_operand(op: &str, line: usize) -> Expression {
+    if let Ok(num) = op.parse::<i64>() {
+        Expression::NumberLiteral(num, line)
+    } else if op.eq_ignore_ascii_case("TRUE") {
+        Expression::BoolLiteral(true, line)
+    } else if op.eq_ignore_ascii_case("FALSE") {
+        Expression::BoolLiteral(false, line)
+    } else {
+        Expression::VariableRef(op.to_string())
+    }
+}
\ No newline at end of file
diff --git a/src/parser/mod.rs b/src/parser/mod.rs
index 4e3abc8..897062d 100644
--- a/src/parser/mod.rs
+++ b/src/parser/mod.rs
@@ -8,6 +8,7 @@ use crate::ast::Program;
 
 pub mod scl;
 pub mod plcopen;
+pub mod il;
 
 /// Parse a PLC source file into a [`Program`]. The file extension
 /// determines which frontend to use:
@@ -23,6 +24,7 @@ pub fn parse_file(path: &Path) -> Result<Program, String> {
     match ext.as_str() {
         "scl" | "st" | "sclsrc" => scl::parse_scl(path),
         "xml" => plcopen::parse_plcopen(path),
+        "il" | "awl"=> il::parse_il(path),
         other => Err(format!(
             "Unsupported file extension: '{}'. Expected .scl/.st or .xml",
             other
diff --git a/src/rules/policy.rs b/src/rules/policy.rs
index 0ee6c14..dcd5737 100644
--- a/src/rules/policy.rs
+++ b/src/rules/policy.rs
@@ -17,7 +17,7 @@ pub struct MemoryArea {
 }
 
 /// Example policy JSON embedded as a constant (not in comments).
-/// You can write this to a file or parse directly with `serde_json`.
+
 pub const EXAMPLE_POLICY_JSON: &str = r#"{
   "pairs": [
     ["Motor_Fwd", "Motor_Rev"],
-- 
2.50.1.windows.1

